# Description
Adaptive Tracing takes a more focused approach to system monitoring. Rather than relying on constant, broad-spectrum observation, it uses targeted watchpoints and trigger conditions to zero in on specific events. This keeps system overhead low and performance high. When something suspicious happens—like signs of an exploit—tracing and response mechanisms kick in right then and there. The idea is straightforward: capture what matters, when it matters. In this scenario, we aim to apply this scenario to an exploit which takes advantage of ACPI tables and using this vulnerability to disable kernel's lockdown status.

##  More about this POC
Our selected use case involves the injection of malicious ACPI tables, a technique attackers might use to bypass lockdown and secure boot restrictions. Naturally, before performing certain actions in the kernel—such as modifying ACPI tables—the Kernel Lockdown status is checked first. However, in older kernel versions, this specific check for ACPI table modifications was missing from the source code. And that gap opened the door for this particular exploit. We will eventually show that this exploit can be adaptively traced the moment it occurs, while avoiding any false positives. The presented POC can be implemented into various scenarios like security and debugging.

## Tools and requirements

- Ubuntu 20.04 

- Kernel 5.7.5 (This exploit is patched in newer versions)

- Bpftrace

- All the scripts are inside the src directory

## How does the exploit work?
This Exploit disables a system's lockdown mechanism, which prevents loading unsigned kernel drivers on Secure Boot systems. It uses the ***acpi_configfs*** module to inject a custom ACPI table, allowing arbitrary writes to physical memory. Below is a general overview of its operation, focusing on ACPI injection, address resolution, and method overriding.

To bypass Kernel Address Space Layout Randomization (KASLR), the script extracts the lockdown variable’s virtual address from _/proc/kallsyms_ and the physical base from _/proc/kcore_. It calculates the physical address using a standard offset, avoiding the need to disable KASLR. Without _/proc/kcore_, older methods like _/proc/iomem_ with _nokaslr_ could work.

Using acpi_configfs, which allows runtime ACPI table loading, the script creates an ASL table (SSDT) that overrides ***_SB.GSIF._STA***, an undefined method evaluated by the kernel on the development system. This method **writes zero to the lockdown variable’s physical address**, disabling lockdown. The method choice is platform-specific, as SSDTs can’t modify DSDT methods but can add new ones. The script compiles the ASL, loads the acpi_configfs module, and injects the table via a kernel filesystem interface. After a brief pause, the kernel processes the table, executing the overridden method.

### Why It Works

The exploit leverages acpi_configfs to inject a trusted ACPI table that manipulates kernel memory. By targeting an undefined method and bypassing KASLR with /proc/kallsyms and /proc/kcore, it reliably disables lockdown with root access, enabling unsigned driver loading in Secure Boot environments.

## How is bpftrace used to detect potential exploit?

The script begins with a BEGIN block that prints a message indicating it is monitoring for ACPI exploit attempts and lockdown status changes. It initializes two state variables, _@modprobe_executed_ and _@aml_opened_, both set to 0. These variables track whether the acpi_configfs module has been loaded and whether an ACPI table has been loaded, respectively. This setup ensures the script can maintain context across events and correlate them to detect the exploit's specific sequence of actions.

```C
BEGIN {
    printf("Monitoring ACPI exploit attempts and lockdown status...\n");
    @modprobe_executed = 0;
    @aml_opened = 0;
}
```

### Monitoring Lockdown Status Changes

The script uses `kprobe` hooks on `lockdown_write` and `security_locked_down` to monitor attempts to modify or check the lockdown status. It retrieves the value of the `kernel_locked_down` variable directly from its kernel address using `kaddr`. If the lockdown value is non-zero (indicating lockdown is active), and both `@modprobe_executed` and `@aml_opened` are set to `1` (indicating prior `acpi_configfs` loading and ACPI table loading), the script flags a potential exploit. It prints details including the process ID and command name that triggered the `acpi_load_table` call and the `modprobe` execution, then resets the state variables. This condition checks for lockdown tampering in the context of the exploit's prerequisites.

```C
kprobe:lockdown_write,
kprobe:security_locked_down
{
    $addr = kaddr("kernel_locked_down");
    $value = *$addr;

    if ($value != 0 && @modprobe_executed == 1 && @aml_opened == 1) {
         printf("kernel lockdown status changed");
         printf("acpi_load_table() called by PID %d (%s)\n", @acpi_pid, @acpi_comm);
         printf("modprobe acpi_configfs executed by PID %d (%s)\n", @exe_pid, @exe_comm);
         printf("Exploit Detected!\n");
         @modprobe_executed = 0;
         @aml_opened = 0;
    }
}
```

### Tracking ACPI Table Loading

A `kprobe` on `acpi_load_table`, the kernel function responsible for loading ACPI tables, sets `@aml_opened` to `1` and records the process ID (`@acpi_pid`) and command name (`@acpi_comm`) of the calling process. The script again checks the `kernel_locked_down` value. If lockdown is active and both `@modprobe_executed` and `@aml_opened` are `1`, it reports a potential exploit, printing the same process details as above and resetting the state variables. This hook is critical because the exploit relies on `acpi_load_table` to inject a malicious ACPI table via `acpi_configfs`.

```C
kprobe:acpi_load_table
{
    @aml_opened = 1;
    @acpi_pid = pid;
    @acpi_comm = comm;

    $addr = kaddr("kernel_locked_down");
    $value = *$addr;
    if ($value != 0 && @modprobe_executed == 1 && @aml_opened == 1) {
         printf("kernel lockdown status changed \n");
         printf("acpi_load_table() called by PID %d (%s)\n", @acpi_pid, @acpi_comm);
         printf("modprobe acpi_configfs executed by PID %d (%s)\n", @exe_pid, @exe_comm);
         printf("Potential Exploit Detected!\n");
         @modprobe_executed = 0;
         @aml_opened = 0;
    }
}
```

### Detecting acpi_configfs Module Loading

The script uses a `tracepoint` on `sys_enter_execve` to monitor executions of the `modprobe` command specifically for loading the `acpi_configfs` module. It checks if the command arguments match `modprobe` and `acpi_configfs`, then sets `@modprobe_executed` to `1` and records the process ID (`@exe_pid`) and command name (`@exe_comm`). As with the other probes, it verifies the `kernel_locked_down` value and checks if both `@modprobe_executed` and `@aml_opened` are `1`. If all conditions are met, it flags an exploit, outputs the relevant process details, and resets the state. This step targets the exploit’s reliance on `acpi_configfs` to enable runtime ACPI table loading.

```C
tracepoint:syscalls:sys_enter_execve
/str(args->argv[0]) == "modprobe" && str(args->argv[1]) == "acpi_configfs"/
{
    @modprobe_executed = 1;
    @exe_pid = pid;
    @exe_comm = comm;

    $addr = kaddr("kernel_locked_down");
    $value = *$addr;
    if ($value != 0 && @modprobe_executed == 1 && @aml_opened == 1) {
         printf("kernel lockdown status changed");
         printf("acpi_load_table() called by PID %d (%s)\n", @acpi_pid, @acpi_comm);
         printf("modprobe acpi_configfs executed by PID %d (%s)\n", @exe_pid, @exe_comm);
         printf("Exploit Detected!\n");
         @modprobe_executed = 0;
         @aml_opened = 0;
    }
}
```

### Why It Works

The script effectively detects the exploit by correlating three specific events: loading the `acpi_configfs` module, calling `acpi_load_table`, and altering the lockdown status from enabled to disabled. These conditions mirror the "American Unsigned Language 3" exploit’s workflow, which uses `acpi_configfs` to inject an ACPI table that disables lockdown via `acpi_load_table`. By monitoring these events with BPFtrace’s kernel probes and tracepoints, the script provides real-time detection of suspicious activity and avoids false-positives. 

## Use of a secondary bash script

A Bash script enhances the BPFtrace script by redirecting its output to the kernel's trace buffer via `/sys/kernel/debug/tracing/trace_marker`. It runs the BPFtrace script and pipes each output line to trace_marker. This makes the BPFtrace detections, such as potential ACPI exploit alerts, accessible through `/sys/kernel/debug/tracing/trace_pipe`, integrating them into the kernel's tracing system for centralized monitoring.

## Demonstration

It can seen that after putting the system under lockdown and running the bpftrace script through the bash script, the potential exploit is detected. It is worth mentioning that enabling the lockdown effect while the trace is being run and running the exploit also works fine and as expected.

![Demo](https://raw.githubusercontent.com/deep-observability-lab/bpftrace-scripts/refs/heads/main/Adaptive%20Tracing%20for%20Real-Time%20Exploit%20Detection/src/demo.png)

## References
- https://git.zx2c4.com/american-unsigned-language/tree/american-unsigned-language-2.sh
- https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=75b0cea7bf307f362057cc778efe89af4c615354
- https://www.cve.org/CVERecord?id=CVE-2020-15780
