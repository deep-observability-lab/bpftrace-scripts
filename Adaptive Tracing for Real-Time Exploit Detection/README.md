# Description
Adaptive Tracing takes a more focused approach to system monitoring. Rather than relying on constant, broad-spectrum observation, it uses targeted watchpoints and trigger conditions to zero in on specific events. This keeps system overhead low and performance high. When something suspicious happens—like signs of an exploit—tracing and response mechanisms kick in right then and there. The idea is straightforward: capture what matters, when it matters. First, we aim to apply this scenario to an exploit which takes advantage of ACPI tables and using this vulnerability to disable kernel's lockdown status. Next, we'll refine our approach based on system call behavior.

- All the scripts are inside the src directory

- **INDEX**
    -
    - [ACPI Exploit](#acpi-exploit)

    - [Rare System Calls](#why-it-works)

    - [Errno values](#why-it-works)

# ACPI Exploit
Our selected use case involves the injection of malicious ACPI tables, a technique attackers might use to bypass lockdown and secure boot restrictions. Naturally, before performing certain actions in the kernel—such as modifying ACPI tables—the Kernel Lockdown status is checked first. However, in older kernel versions, this specific check for ACPI table modifications was missing from the source code. And that gap opened the door for this particular exploit. We will eventually show that this exploit can be adaptively traced the moment it occurs, while avoiding any false positives. The presented POC can be implemented into various scenarios like security and debugging.

- All the scripts are inside the src directory

## How does the exploit work?
This Exploit disables a system's lockdown mechanism, which prevents loading unsigned kernel drivers on Secure Boot systems. It uses the ***acpi_configfs*** module to inject a custom ACPI table, allowing arbitrary writes to physical memory. Below is a general overview of its operation, focusing on ACPI injection, address resolution, and method overriding.

To bypass Kernel Address Space Layout Randomization (KASLR), the script extracts the lockdown variable’s virtual address from _/proc/kallsyms_ and the physical base from _/proc/kcore_. It calculates the physical address using a standard offset, avoiding the need to disable KASLR. Without _/proc/kcore_, older methods like _/proc/iomem_ with _nokaslr_ could work.

Using acpi_configfs, which allows runtime ACPI table loading, the script creates an ASL table (SSDT) that overrides ***_SB.GSIF._STA***, an undefined method evaluated by the kernel on the development system. This method **writes zero to the lockdown variable’s physical address**, disabling lockdown. The method choice is platform-specific, as SSDTs can’t modify DSDT methods but can add new ones. The script compiles the ASL, loads the acpi_configfs module, and injects the table via a kernel filesystem interface. After a brief pause, the kernel processes the table, executing the overridden method.

### Why It Works

The exploit leverages acpi_configfs to inject a trusted ACPI table that manipulates kernel memory. By targeting an undefined method and bypassing KASLR with /proc/kallsyms and /proc/kcore, it reliably disables lockdown with root access, enabling unsigned driver loading in Secure Boot environments.

## How is bpftrace used to detect potential exploit?

The script begins with a BEGIN block that prints a message indicating it is monitoring for ACPI exploit attempts and lockdown status changes. It initializes two state variables, _@modprobe_executed_ and _@aml_opened_, both set to 0. These variables track whether the acpi_configfs module has been loaded and whether an ACPI table has been loaded, respectively. This setup ensures the script can maintain context across events and correlate them to detect the exploit's specific sequence of actions.

```C
BEGIN {
    printf("Monitoring ACPI exploit attempts and lockdown status...\n");
    @modprobe_executed = 0;
    @aml_opened = 0;
}
```

### Monitoring Lockdown Status Changes

The script uses `kprobe` hooks on `lockdown_write` and `security_locked_down` to monitor attempts to modify or check the lockdown status. It retrieves the value of the `kernel_locked_down` variable directly from its kernel address using `kaddr`. If the lockdown value is non-zero (indicating lockdown is active), and both `@modprobe_executed` and `@aml_opened` are set to `1` (indicating prior `acpi_configfs` loading and ACPI table loading), the script flags a potential exploit. It prints details including the process ID and command name that triggered the `acpi_load_table` call and the `modprobe` execution, then resets the state variables. This condition checks for lockdown tampering in the context of the exploit's prerequisites.

```C
kprobe:lockdown_write,
kprobe:security_locked_down
{
    $addr = kaddr("kernel_locked_down");
    $value = *$addr;

    if ($value != 0 && @modprobe_executed == 1 && @aml_opened == 1) {
         printf("kernel lockdown status changed");
         printf("acpi_load_table() called by PID %d (%s)\n", @acpi_pid, @acpi_comm);
         printf("modprobe acpi_configfs executed by PID %d (%s)\n", @exe_pid, @exe_comm);
         printf("Exploit Detected!\n");
         @modprobe_executed = 0;
         @aml_opened = 0;
    }
}
```

### Tracking ACPI Table Loading

A `kprobe` on `acpi_load_table`, the kernel function responsible for loading ACPI tables, sets `@aml_opened` to `1` and records the process ID (`@acpi_pid`) and command name (`@acpi_comm`) of the calling process. The script again checks the `kernel_locked_down` value. If lockdown is active and both `@modprobe_executed` and `@aml_opened` are `1`, it reports a potential exploit, printing the same process details as above and resetting the state variables. This hook is critical because the exploit relies on `acpi_load_table` to inject a malicious ACPI table via `acpi_configfs`.

```C
kprobe:acpi_load_table
{
    @aml_opened = 1;
    @acpi_pid = pid;
    @acpi_comm = comm;

    $addr = kaddr("kernel_locked_down");
    $value = *$addr;
    if ($value != 0 && @modprobe_executed == 1 && @aml_opened == 1) {
         printf("kernel lockdown status changed \n");
         printf("acpi_load_table() called by PID %d (%s)\n", @acpi_pid, @acpi_comm);
         printf("modprobe acpi_configfs executed by PID %d (%s)\n", @exe_pid, @exe_comm);
         printf("Potential Exploit Detected!\n");
         @modprobe_executed = 0;
         @aml_opened = 0;
    }
}
```

### Detecting acpi_configfs Module Loading

The script uses a `tracepoint` on `sys_enter_execve` to monitor executions of the `modprobe` command specifically for loading the `acpi_configfs` module. It checks if the command arguments match `modprobe` and `acpi_configfs`, then sets `@modprobe_executed` to `1` and records the process ID (`@exe_pid`) and command name (`@exe_comm`). As with the other probes, it verifies the `kernel_locked_down` value and checks if both `@modprobe_executed` and `@aml_opened` are `1`. If all conditions are met, it flags an exploit, outputs the relevant process details, and resets the state. This step targets the exploit’s reliance on `acpi_configfs` to enable runtime ACPI table loading.

```C
tracepoint:syscalls:sys_enter_execve
/str(args->argv[0]) == "modprobe" && str(args->argv[1]) == "acpi_configfs"/
{
    @modprobe_executed = 1;
    @exe_pid = pid;
    @exe_comm = comm;

    $addr = kaddr("kernel_locked_down");
    $value = *$addr;
    if ($value != 0 && @modprobe_executed == 1 && @aml_opened == 1) {
         printf("kernel lockdown status changed");
         printf("acpi_load_table() called by PID %d (%s)\n", @acpi_pid, @acpi_comm);
         printf("modprobe acpi_configfs executed by PID %d (%s)\n", @exe_pid, @exe_comm);
         printf("Exploit Detected!\n");
         @modprobe_executed = 0;
         @aml_opened = 0;
    }
}
```

### Why It Works

The script effectively detects the exploit by correlating three specific events: loading the `acpi_configfs` module, calling `acpi_load_table`, and altering the lockdown status from enabled to disabled. These conditions mirror the "American Unsigned Language 3" exploit’s workflow, which uses `acpi_configfs` to inject an ACPI table that disables lockdown via `acpi_load_table`. By monitoring these events with BPFtrace’s kernel probes and tracepoints, the script provides real-time detection of suspicious activity and avoids false-positives. 

## Use of a secondary bash script

A Bash script enhances the BPFtrace script by redirecting its output to the kernel's trace buffer via `/sys/kernel/debug/tracing/trace_marker`. It runs the BPFtrace script and pipes each output line to trace_marker. This makes the BPFtrace detections, such as potential ACPI exploit alerts, accessible through `/sys/kernel/debug/tracing/trace_pipe`, integrating them into the kernel's tracing system for centralized monitoring.

## Demonstration

It can seen that after putting the system under lockdown and running the bpftrace script through the bash script, the potential exploit is detected. It is worth mentioning that enabling the lockdown effect while the trace is being run and running the exploit also works fine and as expected.

![Demo](https://raw.githubusercontent.com/deep-observability-lab/bpftrace-scripts/refs/heads/main/Adaptive%20Tracing%20for%20Real-Time%20Exploit%20Detection/src/demo.png)



# Rare System Calls
Building on the adaptive tracing goals outlined in [ACPI Exploit](#acpi-exploit), we've established two methods that can be used either independently or in combination: identifying rare system calls and detecting negative return values.

System calls are invoked with varying arguments, but their frequency of occurrence is crucial for our analysis. We can log the frequency of similar system calls with identical argument values. By comparing newly called system calls against these prior knowledge of frequencies, we can effectively detect anomalies.

### Why It Works
To gather frequencies of normally invoked system calls, we trace the system for a specified duration while performing typical tasks and workloads. This provides valuable data on which system calls, and with what argument combinations, are frequently invoked and what number of times. The unique combination of arguments per system call is what enables us to compare any new system call against this established baseline.

If a systemcall is not among the previousley logged system call combinations or is below a certain thershold level, it is considered rare or anomily.

### How It Works

The approach consists of two phases: the **learning phase** and the **comparison phase**.

During the learning phase, the system records various system calls and their associated argument combinations under typical runtime conditions. These recorded and counted combinations establish a baseline for normal activity and are not treated as anomalies. The information collected in this phase serves as reference data for detecting anomalies during the comparison phase.

For demonstration purposes, and without loss of generality, we focus on two specific system calls: `openat` and `mmap`.

```C
BEGIN {
    @openat_baseline[0,0] = 686708;
    @openat_baseline[1,0] = 33;
    @openat_baseline[2,0] = 26;
    @openat_baseline[66,438] = 19;
    @openat_baseline[194,384] = 11;
    @openat_baseline[577,384] = 2;
    @openat_baseline[577,420] = 14;
    @openat_baseline[577,438] = 112;
    @openat_baseline[2050,0] = 19;
    @openat_baseline[2241,420] = 1;
    :
    :
    @mmap_baseline[0,34] = 114;
    @mmap_baseline[0,50] = 16;
    @mmap_baseline[0,16418] = 90;
    @mmap_baseline[0,131106] = 95;
    @mmap_baseline[1,1] = 218;
    @mmap_baseline[1,2] = 5394;
    @mmap_baseline[1,2050] = 8544;
    @mmap_baseline[1,2066] = 8550;
    :
    :
    :
}

tracepoint:syscalls:sys_enter_openat {
    $f = args->flags;
    $m = args->mode;

    /* unseen or rare combo → anomaly */
    if (!@openat_baseline[$f,$m] || @openat_baseline[$f,$m] < $1) {
        @openat_anomaly[$f,$m]++;
        printf("\n=== Potential Anomaly openat pid=%d comm=%s flags=%x mode=%o ===\n", pid, comm, $f, $m);
        @openat_baseline[$f,$m]++;
    }
}

tracepoint:syscalls:sys_enter_mmap {
    $f = args->prot;
    $m = args->flags;

    /* unseen or rare combo → anomaly */
    if (!@mmap_baseline[$f,$m] || @mmap_baseline[$f,$m] < $1) {
        @mmap_anomaly[$f,$m]++;
        printf("\n=== Potential Anomaly mmap pid=%d comm=%s flags=%x mode=%o ===\n", pid, comm, $f, $m);
        @mmap_baseline[$f,$m]++;
    }
}
```

As demonstrated in the script above, the data collected during the learning phase is used as input for the comparison phase. If a new system call combination is encountered that was not previously observed, it is flagged as an anomaly. At the same time, this new combination is added to the known list, which helps reduce false positives over time.

It is also worth noting that we use the `sys_enter_` tracepoint instead of `raw_syscall_entry`. This choice is influenced by several factors, such as:


| Feature         | `raw_syscall_entry` (`raw_syscalls:sys_enter`)    | `sys_enter_mmap` (`syscalls:sys_enter_<nameOfTheSyscall>`)      |
|-----------------|---------------------------------------------------|---------------------------------------------------|
| Fires for       | **All syscalls**                                  | Only the `mmap` syscall                           |
| Args Provided   | Syscall number + raw arguments (generic)          | Named fields, typed for `mmap` (addr, len, prot, flags, fd, off) |
| Usage           | Broad tracing, logging all syscalls               | Specific tracing for mmap, detailed params        |
| Overhead        | Higher (for just mmap)                            | Lower (only triggers on mmap)                     |

If `raw_syscall_` is used, various post-proccessing scripts can be written to output and print meaningful information out of raw data. For instance, below is a demontration of proccessing the path for file descriptors and printing, simply by proccessing the raw arguments of `fd`:

<!-- fd raw -->

## References
- https://git.zx2c4.com/american-unsigned-language/tree/american-unsigned-language-2.sh
- https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=75b0cea7bf307f362057cc778efe89af4c615354
- https://www.cve.org/CVERecord?id=CVE-2020-15780
