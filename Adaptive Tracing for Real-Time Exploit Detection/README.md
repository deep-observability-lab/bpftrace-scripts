# Description
Adaptive Tracing takes a more focused approach to system monitoring. Rather than relying on constant, broad-spectrum observation, it uses targeted watchpoints and trigger conditions to zero in on specific events. This keeps system overhead low and performance high. When something suspicious happens—like signs of an exploit—tracing and response mechanisms kick in right then and there. The idea is straightforward: capture what matters, when it matters. First, we aim to apply this scenario to an exploit which takes advantage of ACPI tables and using this vulnerability to disable kernel's lockdown status. Next, we'll refine our approach based on system call behavior.

- All the scripts are inside the src directory

- **INDEX**
    -
    - [ACPI Exploit](#acpi-exploit)

    - [Rare System Calls](#rare-system-calls)

    - [Errno values](#errno-values)

# ACPI Exploit
Our selected use case involves the injection of malicious ACPI tables, a technique attackers might use to bypass lockdown and secure boot restrictions. Naturally, before performing certain actions in the kernel—such as modifying ACPI tables—the Kernel Lockdown status is checked first. However, in older kernel versions, this specific check for ACPI table modifications was missing from the source code. And that gap opened the door for this particular exploit. We will eventually show that this exploit can be adaptively traced the moment it occurs, while avoiding any false positives. The presented POC can be implemented into various scenarios like security and debugging.

- All the scripts are inside the src directory

## How does the exploit work?
This Exploit disables a system's lockdown mechanism, which prevents loading unsigned kernel drivers on Secure Boot systems. It uses the ***acpi_configfs*** module to inject a custom ACPI table, allowing arbitrary writes to physical memory. Below is a general overview of its operation, focusing on ACPI injection, address resolution, and method overriding.

To bypass Kernel Address Space Layout Randomization (KASLR), the script extracts the lockdown variable’s virtual address from _/proc/kallsyms_ and the physical base from _/proc/kcore_. It calculates the physical address using a standard offset, avoiding the need to disable KASLR. Without _/proc/kcore_, older methods like _/proc/iomem_ with _nokaslr_ could work.

Using acpi_configfs, which allows runtime ACPI table loading, the script creates an ASL table (SSDT) that overrides ***_SB.GSIF._STA***, an undefined method evaluated by the kernel on the development system. This method **writes zero to the lockdown variable’s physical address**, disabling lockdown. The method choice is platform-specific, as SSDTs can’t modify DSDT methods but can add new ones. The script compiles the ASL, loads the acpi_configfs module, and injects the table via a kernel filesystem interface. After a brief pause, the kernel processes the table, executing the overridden method.

### Why It Works

The exploit leverages acpi_configfs to inject a trusted ACPI table that manipulates kernel memory. By targeting an undefined method and bypassing KASLR with /proc/kallsyms and /proc/kcore, it reliably disables lockdown with root access, enabling unsigned driver loading in Secure Boot environments.

## How is bpftrace used to detect potential exploit?

The script begins with a BEGIN block that prints a message indicating it is monitoring for ACPI exploit attempts and lockdown status changes. It initializes two state variables, _@modprobe_executed_ and _@aml_opened_, both set to 0. These variables track whether the acpi_configfs module has been loaded and whether an ACPI table has been loaded, respectively. This setup ensures the script can maintain context across events and correlate them to detect the exploit's specific sequence of actions.

```C
BEGIN {
    printf("Monitoring ACPI exploit attempts and lockdown status...\n");
    @modprobe_executed = 0;
    @aml_opened = 0;
}
```

### Monitoring Lockdown Status Changes

The script uses `kprobe` hooks on `lockdown_write` and `security_locked_down` to monitor attempts to modify or check the lockdown status. It retrieves the value of the `kernel_locked_down` variable directly from its kernel address using `kaddr`. If the lockdown value is non-zero (indicating lockdown is active), and both `@modprobe_executed` and `@aml_opened` are set to `1` (indicating prior `acpi_configfs` loading and ACPI table loading), the script flags a potential exploit. It prints details including the process ID and command name that triggered the `acpi_load_table` call and the `modprobe` execution, then resets the state variables. This condition checks for lockdown tampering in the context of the exploit's prerequisites.

```C
kprobe:lockdown_write,
kprobe:security_locked_down
{
    $addr = kaddr("kernel_locked_down");
    $value = *$addr;

    if ($value != 0 && @modprobe_executed == 1 && @aml_opened == 1) {
         printf("kernel lockdown status changed");
         printf("acpi_load_table() called by PID %d (%s)\n", @acpi_pid, @acpi_comm);
         printf("modprobe acpi_configfs executed by PID %d (%s)\n", @exe_pid, @exe_comm);
         printf("Exploit Detected!\n");
         @modprobe_executed = 0;
         @aml_opened = 0;
    }
}
```

### Tracking ACPI Table Loading

A `kprobe` on `acpi_load_table`, the kernel function responsible for loading ACPI tables, sets `@aml_opened` to `1` and records the process ID (`@acpi_pid`) and command name (`@acpi_comm`) of the calling process. The script again checks the `kernel_locked_down` value. If lockdown is active and both `@modprobe_executed` and `@aml_opened` are `1`, it reports a potential exploit, printing the same process details as above and resetting the state variables. This hook is critical because the exploit relies on `acpi_load_table` to inject a malicious ACPI table via `acpi_configfs`.

```C
kprobe:acpi_load_table
{
    @aml_opened = 1;
    @acpi_pid = pid;
    @acpi_comm = comm;

    $addr = kaddr("kernel_locked_down");
    $value = *$addr;
    if ($value != 0 && @modprobe_executed == 1 && @aml_opened == 1) {
         printf("kernel lockdown status changed \n");
         printf("acpi_load_table() called by PID %d (%s)\n", @acpi_pid, @acpi_comm);
         printf("modprobe acpi_configfs executed by PID %d (%s)\n", @exe_pid, @exe_comm);
         printf("Potential Exploit Detected!\n");
         @modprobe_executed = 0;
         @aml_opened = 0;
    }
}
```

### Detecting acpi_configfs Module Loading

The script uses a `tracepoint` on `sys_enter_execve` to monitor executions of the `modprobe` command specifically for loading the `acpi_configfs` module. It checks if the command arguments match `modprobe` and `acpi_configfs`, then sets `@modprobe_executed` to `1` and records the process ID (`@exe_pid`) and command name (`@exe_comm`). As with the other probes, it verifies the `kernel_locked_down` value and checks if both `@modprobe_executed` and `@aml_opened` are `1`. If all conditions are met, it flags an exploit, outputs the relevant process details, and resets the state. This step targets the exploit’s reliance on `acpi_configfs` to enable runtime ACPI table loading.

```C
tracepoint:syscalls:sys_enter_execve
/str(args->argv[0]) == "modprobe" && str(args->argv[1]) == "acpi_configfs"/
{
    @modprobe_executed = 1;
    @exe_pid = pid;
    @exe_comm = comm;

    $addr = kaddr("kernel_locked_down");
    $value = *$addr;
    if ($value != 0 && @modprobe_executed == 1 && @aml_opened == 1) {
         printf("kernel lockdown status changed");
         printf("acpi_load_table() called by PID %d (%s)\n", @acpi_pid, @acpi_comm);
         printf("modprobe acpi_configfs executed by PID %d (%s)\n", @exe_pid, @exe_comm);
         printf("Exploit Detected!\n");
         @modprobe_executed = 0;
         @aml_opened = 0;
    }
}
```

### Why It Works

The script effectively detects the exploit by correlating three specific events: loading the `acpi_configfs` module, calling `acpi_load_table`, and altering the lockdown status from enabled to disabled. These conditions mirror the "American Unsigned Language 3" exploit’s workflow, which uses `acpi_configfs` to inject an ACPI table that disables lockdown via `acpi_load_table`. By monitoring these events with BPFtrace’s kernel probes and tracepoints, the script provides real-time detection of suspicious activity and avoids false-positives. 

## Use of a secondary bash script

A Bash script enhances the BPFtrace script by redirecting its output to the kernel's trace buffer via `/sys/kernel/debug/tracing/trace_marker`. It runs the BPFtrace script and pipes each output line to trace_marker. This makes the BPFtrace detections, such as potential ACPI exploit alerts, accessible through `/sys/kernel/debug/tracing/trace_pipe`, integrating them into the kernel's tracing system for centralized monitoring.

## Demonstration

It can seen that after putting the system under lockdown and running the bpftrace script through the bash script, the potential exploit is detected. It is worth mentioning that enabling the lockdown effect while the trace is being run and running the exploit also works fine and as expected.

![Demo](https://raw.githubusercontent.com/deep-observability-lab/bpftrace-scripts/refs/heads/main/Adaptive%20Tracing%20for%20Real-Time%20Exploit%20Detection/src/demo.png)



# Rare System Calls
Building on the adaptive tracing goals outlined in [ACPI Exploit](#acpi-exploit), we've established two methods that can be used either independently or in combination: identifying rare system calls and detecting negative return values.

System calls are invoked with varying arguments, but their frequency of occurrence is crucial for our analysis. We can log the frequency of similar system calls with identical argument values. By comparing newly called system calls against these prior knowledge of frequencies, we can effectively detect anomalies.

### Why It Works
To gather frequencies of normally invoked system calls, we trace the system for a specified duration while performing typical tasks and workloads. This provides valuable data on which system calls, and with what argument combinations, are frequently invoked and what number of times. The unique combination of arguments per system call is what enables us to compare any new system call against this established baseline.

If a systemcall is not among the previousley logged system call combinations or is below a certain thershold level, it is considered rare or anomily.

### How It Works

The approach consists of two phases: the **learning phase** and the **comparison phase**.

During the learning phase, the system records various system calls and their associated argument combinations under typical runtime conditions. These recorded and counted combinations establish a baseline for normal activity and are not treated as anomalies. The information collected in this phase serves as reference data for detecting anomalies during the comparison phase.

For demonstration purposes, and without loss of generality, we focus on two specific system calls: `openat` and `mmap`.

```C
BEGIN {
    @openat_baseline[0,0] = 686708;
    @openat_baseline[1,0] = 33;
    @openat_baseline[2,0] = 26;
    @openat_baseline[66,438] = 19;
    @openat_baseline[194,384] = 11;
    @openat_baseline[577,384] = 2;
    @openat_baseline[577,420] = 14;
    @openat_baseline[577,438] = 112;
    @openat_baseline[2050,0] = 19;
    @openat_baseline[2241,420] = 1;
    :
    :
    @mmap_baseline[0,34] = 114;
    @mmap_baseline[0,50] = 16;
    @mmap_baseline[0,16418] = 90;
    @mmap_baseline[0,131106] = 95;
    @mmap_baseline[1,1] = 218;
    @mmap_baseline[1,2] = 5394;
    @mmap_baseline[1,2050] = 8544;
    @mmap_baseline[1,2066] = 8550;
    :
    :
    :
}

tracepoint:syscalls:sys_enter_openat {
    $f = args->flags;
    $m = args->mode;

    /* unseen or rare combo → anomaly */
    if (!@openat_baseline[$f,$m] || @openat_baseline[$f,$m] < $1) {
        @openat_anomaly[$f,$m]++;
        printf("\n=== Potential Anomaly openat pid=%d comm=%s flags=%x mode=%o ===\n", pid, comm, $f, $m);
        @openat_baseline[$f,$m]++;
    }
}

tracepoint:syscalls:sys_enter_mmap {
    $f = args->prot;
    $m = args->flags;

    /* unseen or rare combo → anomaly */
    if (!@mmap_baseline[$f,$m] || @mmap_baseline[$f,$m] < $1) {
        @mmap_anomaly[$f,$m]++;
        printf("\n=== Potential Anomaly mmap pid=%d comm=%s flags=%x mode=%o ===\n", pid, comm, $f, $m);
        @mmap_baseline[$f,$m]++;
    }
}
```

As demonstrated in the script above, the data collected during the learning phase is used as input for the comparison phase. If a new system call combination is encountered that was not previously observed, it is flagged as an anomaly. At the same time, this new combination is added to the known list, which helps reduce false positives over time. A thresshold value is also put to filter the output. 

<!-- rare syscall example-->
![rare_syscall_example](https://github.com/deep-observability-lab/bpftrace-scripts/blob/main/Adaptive%20Tracing%20for%20Real-Time%20Exploit%20Detection/src/rare_syscall_example.png)

It is also worth noting that we use the `sys_enter_` tracepoint instead of `raw_syscall_entry`. This choice is influenced by several factors, such as:


| Feature         | `raw_syscall_entry` (`raw_syscalls:sys_enter`)    | `sys_enter_` (`syscalls:sys_enter_<nameOfTheSyscall>`)      |
|-----------------|---------------------------------------------------|---------------------------------------------------|
| Fires for       | **All syscalls**                                  | Only the specific syscall                           |
| Args Provided   | Syscall number + raw arguments (generic)          | Named fields, typed for the specific syscall (addr, len, prot, flags, fd, off) |
| Usage           | Broad tracing, logging all syscalls               | Specific syscall tracing, detailed params        |
| Overhead        | Higher (for just mmap)                            | Lower (only triggers on mmap)                     |

If `raw_syscall_` is used, additional post-processing scripts are often required to extract and present meaningful information from the raw argument data. For example, the snippet below demonstrates how to process a file descriptor argument to resolve and print the actual file path by interpreting the raw input of the `fd` parameter:

<!-- fd raw -->
![fd raw](https://github.com/deep-observability-lab/bpftrace-scripts/blob/main/Adaptive%20Tracing%20for%20Real-Time%20Exploit%20Detection/src/raw_fd.png)

# Errno values

In addition to using syscall combinations to detect anomalies, errno return values also provide useful information when a system call fails. The kernel sets errno to indicate when and why the call didn't succeed—common examples include _permission denied, invalid file descriptor,_ or _resource temporarily unavailable_. Tracking these error codes alongside syscall patterns helps improve detection accuracy and makes it easier to understand what went wrong when unexpected behavior occurs.

### How It Works

To capture both the raw arguments of a system call and the exact error code it returns, we attach probes to **`raw_syscall_entry`** and **`raw_syscall_exit`**.

* **`raw_syscall_entry`** fires at call, exposing raw arguments (file-descriptor numbers, paths, flags, lengths).
* **`raw_syscall_exit`** fires on return; a negative value maps to symbolic errnos such as `EPERM`, `EBADF`, or `EAGAIN`.

For clear post-processing, the bpfscript should emit two fields per event:

1. **Syscall name** – look up the syscall number and map it to a name, for example openat, mmap, or clone3.
2. **Errno category** – the symbolic errno label. Typical categories include *permission denied* (`EPERM`), *invalid file descriptor* (`EBADF`), *resource temporarily unavailable* (`EAGAIN`), and so on.

To include both syscall names and errno categories in the output using bpftrace, we use map initialization. This involves creating maps where syscall numbers and errno codes are used as keys, and their corresponding names or categories are set as values. By doing this, the script can easily look up and print human-readable syscall names and errno labels during execution.

```C
BEGIN
{
    @errno[1]   = 1; // EPERM         - Operation not permitted
    @errno[2]   = 1; // ENOENT        - No such file or directory
    @errno[3]   = 1; // ESRCH         - No such process
    @errno[4]   = 1; // EINTR         - Interrupted system call
    @errno[5]   = 1; // EIO           - I/O error
    @errno[6]   = 1; // ENXIO         - No such device or address
    @errno[7]   = 1; // E2BIG         - Argument list too long
    @errno[8]   = 1; // ENOEXEC       - Exec format error
    @errno[9]   = 1; // EBADF         - Bad file number
    @errno[10]  = 1; // ECHILD        - No child processes
    :
    :
    @name[0] = "read";
    @name[1] = "write";
    @name[2] = "open";
    @name[3] = "close";
    @name[4] = "stat";
    @name[5] = "fstat";
    @name[6] = "lstat";
    @name[7] = "poll";
    @name[8] = "lseek";
    @name[9] = "mmap";
    @name[10] = "mprotect";
    @name[11] = "munmap";
    :
    :

}

tracepoint:raw_syscalls:sys_enter
{
    @nr[tid] = args->id;
    @a0[tid] = args->args[0];
    @a1[tid] = args->args[1];
    @a2[tid] = args->args[2];
    @a3[tid] = args->args[3];
    @a4[tid] = args->args[4];
    @a5[tid] = args->args[5];
}

tracepoint:raw_syscalls:sys_exit /@errno[-args->ret] && comm == "exploit"/
{
        $nr = @nr[tid];
        $s = "unknown";
        if (@name[$nr] != "") {
            $s = @name[$nr];
        }

        printf("%-16s %-18s errno=%d args=[0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx]\n",
               comm, $s, -args->ret,
               @a0[tid], @a1[tid], @a2[tid],
               @a3[tid], @a4[tid], @a5[tid]);

    delete(@nr[tid]); delete(@a0[tid]); delete(@a1[tid]); delete(@a2[tid]);
    delete(@a3[tid]); delete(@a4[tid]); delete(@a5[tid]);
}
```

- Printing the output in terminal has a lot of overhead but print function is put here just for demonstration.

# Uses Cases

Use cases apply to both security and application-level contexts.

## CVE-2021-3490 – eBPF Verifier Exploit Attempts and EINVAL

Several high-profile vulnerabilities in the eBPF verifier allowed local privilege escalation by crafting malicious BPF programs. Exploitation involves feeding invalid or extreme instructions to the BPF verifier to confuse it into out-of-bounds accesses.

This usecase involve rare argumnets for `setsockopt` and `socketpair` syscalls and is easily detected.

## CVE-2024-1086 - use-after-free bug in the Linux kernel’s netfilter

CVE-2024-1086 is a high-severity use-after-free flaw in the Linux kernel’s nf_tables firewall code, where a logic mistake lets a freed verdict object be referenced again; an unprivileged local user who can add or modify nftables rules can exploit the dangling pointer to overwrite kernel memory and gain full root privileges, including escaping containers. Reliable proof-of-concept exploits appeared soon after disclosure.

This use case triggers multiple `ENOEXEC` errno values for the `execveat` system call. These errors can be detected by monitoring errno return codes, allowing us to identify unusual or repeated execution failures linked to this specific syscall.


## Linux Process Capability Control and Restriction (like _CAP_READ_, _CAP_NET_BIND_SERVICE_, etc.)

On Linux, capabilities enable fine‑grained privilege control—rather than granting full root permissions, you can assign specific privileges (like granting the ability to bind to port 80 via `CAP_NET_BIND_SERVICE`) or restrict a program’s rights using tools such as `getcap`/`setcap`, `capsh`, or `getpcaps`, thereby reducing the attack surface while preserving necessary functionality.

Sometimes, the errors we encounter are too general—such as a `login failed` message in ftp—which could actually be caused by missing Linux capabilities. To the user, the real reason remains unclear. Therefore, depending on the situation, combining both approaches can help us better understand the root cause.



## References
- https://git.zx2c4.com/american-unsigned-language/tree/american-unsigned-language-2.sh
- https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=75b0cea7bf307f362057cc778efe89af4c615354
- https://www.cve.org/CVERecord?id=CVE-2020-15780
